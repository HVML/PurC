#!/usr/bin/purc

# RESULT: 'Good Client'

<hvml target="void">
    <head>
        <define as 'logMsg'>
            $RUNNER.enablelog('all', 'stderr')

            <inherit>
                $RUNNER.logmsg($?)
            </inherit>
        </define>
    </head>

    <body id='server' >

        <include with $logMsg on 'The server is running...' />

        <init as 'sslSettings' with {} />
        <test with $L.streq('caseless', $REQ.secure, 'true') >
            <update on $sslSettings to 'merge'>
                {
                    'sslkey': '../Source/test/dvobjs/localhost.key',
                    'sslcert': '../Source/test/dvobjs/localhost.crt',
                }
            </update>
        </test>

        <init as 'wsSettings' >
                {
                    'noresptimetoping': 3,
                    'noresptimetoclose': 6,
                }
        </init>

        <include with $logMsg on $DATA.serialize($sslSettings) />
        <include with $logMsg on $DATA.serialize($wsSettings) />

        <init as 'clients' with {} />

        <init as 'srvListenSocket' with $SOCKET.stream('inet://localhost:8080', 'none', 32, $sslSettings) >
            <catch for `ANY`>
                <exit with "Server failed with $?.name when calling SOCKET.stream()" />
            </catch>
        </init>

        <include with $logMsg on 'The server is accepting...' />

        <observe on $srvListenSocket for 'connAttempt'>
            <choose on $srvListenSocket.accept('default', 'websocket', $wsSettings)>
                <catch for `ANY`>
                    <exit with "Server failed with $?.name when calling accept()" />
                </catch>

                <test with $L.not($DATA.isequal($?, null)) >

                    <include with $logMsg on "Server accpeted a client from $?.peerAddr:$?.peerPort" />

                    <init as 'clientId' with "$?.peerAddr:$?.peerPort" temp />

                    <update on $clients to 'merge' with { $clientId : $? } />

                    <observe on $clients[$clientId] for 'handshake'>
                        $clientId

                        <inherit>
                        {{
                            $STREAM.stdout.writelines("Server got HANDSHAKE event from `$_observedContent`; payload:");
                            $STREAM.stdout.writelines($DATA.serialize($?));
                            $_observedOn.send_handshake_resp(101);
                        }}
                        </inherit>

                        <!-- TODO: send initial message to client -->
                    </observe>

                    <observe on $clients[$clientId] for 'message'>
                        $clientId

                        <include with $logMsg on "Server got ERROR event from `$_observedContent`; payload:" />
                        <include with $logMsg on $DATA.serialize($?) />

                        <!-- TODO: handle message here -->
                    </observe>

                    <observe on $clients[$clientId] for 'error'>
                        $clientId

                        <include with $logMsg on "Server got ERROR event from `$_observedContent`; payload:" />
                        <include with $logMsg on $DATA.serialize($?) />

                        <update on $clients at ".$_observedContent" to 'remove' />
                        <forget on $_observedOn for '*' />
                    </observe>

                    <observe on $clients[$clientId] for 'close'>
                        $clientId

                        <include with $logMsg on "Server got CLOSE event from `$_observedContent`; payload:" />
                        <include with $logMsg on $DATA.serialize($?) />

                        <update on $clients at ".$_observedContent" to 'remove' />
                        <forget on $_observedOn for '*' />
                    </observe>
                </test>
            </choose>
        </observe>
    </body>
</hvml>

